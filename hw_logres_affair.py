# -*- coding: utf-8 -*-
"""HW Logres_affair.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E-XzGuoE_i-Hql4YI4KnxapgOKtEJHA7
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder

# Загрузка данных
data = pd.read_csv('athletes.csv')

# Создание целевого столбца
data['target'] = (data['gold'] + data['silver'] + data['bronze']) > 0
data['target'] = data['target'].astype(int)

# Удаление ненужных столбцов
data = data.drop(['id', 'name', 'dob'], axis=1)

# Заполнение пропущенных значений
data['height'].fillna(data['height'].mean(), inplace=True)
data['weight'].fillna(data['weight'].mean(), inplace=True)

# Кодирование категориальных переменных
label_encoders = {}
for column in data.select_dtypes(include=['object']).columns:
    le = LabelEncoder()
    data[column] = le.fit_transform(data[column])
    label_encoders[column] = le

# Разделение данных на признаки и целевую переменную
X = data.drop('target', axis=1)
y = data['target']

# Масштабирование признаков
scaler = StandardScaler()
X = scaler.fit_transform(X)

# Разделение на обучающую и тестовую выборки
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Проверка подготовки данных
print("Training data shape:", X_train.shape)
print("Test data shape:", X_test.shape)
print("Sample data:")
print(data.head())

"""Обучение модели лог регресии и построение ROC кривой"""

from sklearn.linear_model import LogisticRegression
from sklearn.metrics import roc_curve, roc_auc_score, precision_recall_curve

# Обучение модели логистической регрессии
model = LogisticRegression()
model.fit(X_train, y_train)

# Предсказания вероятностей
y_scores = model.predict_proba(X_test)[:, 1]

# Построение ROC-кривой
fpr, tpr, thresholds = roc_curve(y_test, y_scores)
roc_auc = roc_auc_score(y_test, y_scores)

# Построение графика ROC-кривой
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
plt.plot(fpr, tpr, label=f'ROC curve (area = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], 'k--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Kurve')
plt.legend(loc="lower right")
plt.show()

"""Подсчет TPR and FPR"""

# Вычисление метрик вручную
thresholds_manual = sorted(set(y_scores), reverse=True)
tpr_manual = []
fpr_manual = []

for threshold in thresholds_manual:
    tp = fp = fn = tn = 0
    for i in range(len(y_test)):
        if y_scores[i] >= threshold:
            if y_test.iloc[i] == 1:
                tp += 1
            else:
                fp += 1
        else:
            if y_test.iloc[i] == 1:
                fn += 1
            else:
                tn += 1
    tpr_manual.append(tp / (tp + fn))
    fpr_manual.append(fp / (fp + tn))

# Построение графика ROC-кривой с ручными метриками
plt.figure(figsize=(10, 6))
plt.plot(fpr, tpr, label='ROC curve (sklearn)')
plt.plot(fpr_manual, tpr_manual, label='ROC curve (manual)', linestyle='--')
plt.plot([0, 1], [0, 1], 'k--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()

"""Graph Precision-Recall"""

# Построение графика Precision-Recall
precision, recall, _ = precision_recall_curve(y_test, y_scores)

plt.figure(figsize=(10, 6))
plt.plot(recall, precision, marker='.')
plt.xlabel('Recall')
plt.ylabel('Precision')
plt.title('Precision-Recall curve')
plt.show()

"""Вычисление ROC AUC"""

# Вычисление значения ROC-AUC метрики вручную
roc_auc_manual = 0.0
for i in range(1, len(fpr_manual)):
    roc_auc_manual += (fpr_manual[i] - fpr_manual[i-1]) * (tpr_manual[i] + tpr_manual[i-1]) / 2

print(f'ROC-AUC (manual): {roc_auc_manual:.2f}')